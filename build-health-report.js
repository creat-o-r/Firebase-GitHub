#!/usr/bin/env node

/**
 * Build Health Monitoring & Proactive Fixing
 * Analyzes build patterns and automatically fixes common issues
 */

const { execSync } = require('child_process');
const fs = require('fs');

class BuildHealthMonitor {
  constructor() {
    this.githubToken = this.getGitHubToken();
    this.repo = process.env.GITHUB_REPOSITORY || 'creat-o-r/Barterverse';
  }

  getGitHubToken() {
    try {
      return execSync('gcloud secrets versions access latest --secret="github-token" --project="barterverse-l9uq3"', 
        { encoding: 'utf8' }).trim();
    } catch (error) {
      console.error('Failed to get GitHub token:', error.message);
      process.exit(1);
    }
  }

  async getRecentBuilds(hours = 24) {
    const since = new Date(Date.now() - hours * 60 * 60 * 1000).toISOString();
    
    const response = await fetch(`https://api.github.com/repos/${this.repo}/actions/runs?per_page=100`, {
      headers: { 'Authorization': `token ${this.githubToken}` }
    });
    
    const data = await response.json();
    return data.workflow_runs.filter(run => new Date(run.created_at) > new Date(since));
  }

  analyzeFailurePatterns(builds) {
    const failures = builds.filter(build => build.conclusion === 'failure');
    const patterns = {
      dependency_issues: 0,
      permission_errors: 0,
      network_timeouts: 0,
      build_errors: 0,
      deployment_failures: 0
    };

    const branchFailures = {};
    const timeFailures = {};

    failures.forEach(failure => {
      // Track failures by branch
      const branch = failure.head_branch || 'unknown';
      branchFailures[branch] = (branchFailures[branch] || 0) + 1;

      // Track failures by time of day
      const hour = new Date(failure.created_at).getHours();
      timeFailures[hour] = (timeFailures[hour] || 0) + 1;
    });

    return {
      patterns,
      branchFailures,
      timeFailures,
      totalFailures: failures.length,
      failureRate: (failures.length / builds.length * 100).toFixed(2)
    };
  }

  async getFailureLogs(runId) {
    try {
      const response = await fetch(`https://api.github.com/repos/${this.repo}/actions/runs/${runId}/logs`, {
        headers: { 'Authorization': `token ${this.githubToken}` }
      });
      
      if (response.ok) {
        return await response.arrayBuffer();
      }
    } catch (error) {
      console.error(`Failed to get logs for run ${runId}:`, error.message);
    }
    return null;
  }

  generatePredictiveInsights(analysis) {
    const insights = [];

    // High failure rate alert
    if (analysis.failureRate > 25) {
      insights.push({
        type: 'critical',
        message: `Critical: ${analysis.failureRate}% failure rate requires immediate attention`,
        action: 'investigate_immediately'
      });
    }

    // Branch-specific issues
    Object.entries(analysis.branchFailures).forEach(([branch, count]) => {
      if (count > 3) {
        insights.push({
          type: 'warning',
          message: `Branch "${branch}" has ${count} recent failures - may need investigation`,
          action: `review_branch_${branch}`
        });
      }
    });

    // Time-based patterns
    const peakFailureHour = Object.entries(analysis.timeFailures)
      .sort(([,a], [,b]) => b - a)[0];
      
    if (peakFailureHour && peakFailureHour[1] > 5) {
      insights.push({
        type: 'info',
        message: `Most failures occur at ${peakFailureHour[0]}:00 UTC (${peakFailureHour[1]} failures)`,
        action: 'schedule_maintenance_window'
      });
    }

    return insights;
  }

  async createAutoFixPR(fixes) {
    if (fixes.length === 0) return;

    const branchName = `auto-fix-${Date.now()}`;
    
    try {
      execSync(`git checkout -b ${branchName}`);
      
      fixes.forEach(fix => {
        execSync(fix.command);
      });

      if (execSync('git status --porcelain', { encoding: 'utf8' }).trim()) {
        execSync('git add .');
        execSync(`git commit -m "ðŸ”§ Automated fixes for build issues

${fixes.map(f => `- ${f.description}`).join('\\n')}

ðŸ¤– Generated by Build Health Monitor"`);

        execSync(`git push origin ${branchName}`);

        // Create PR
        await fetch(`https://api.github.com/repos/${this.repo}/pulls`, {
          method: 'POST',
          headers: {
            'Authorization': `token ${this.githubToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            title: 'ðŸ”§ Automated Build Health Fixes',
            body: `## Automated Fixes Applied

${fixes.map(f => `- **${f.description}**\\n  Command: \`${f.command}\``).join('\\n\\n')}

This PR was automatically created by the build health monitoring system to address common build issues.

**Review Required**: Please verify these changes before merging.`,
            head: branchName,
            base: 'main'
          })
        });

        console.log(`âœ… Created auto-fix PR on branch ${branchName}`);
      }
    } catch (error) {
      console.error('Failed to create auto-fix PR:', error.message);
    }
  }

  async createBuildIssue(failureRate, insights) {
    if (failureRate > 50) {
      try {
        await fetch(`https://api.github.com/repos/${this.repo}/issues`, {
          method: 'POST',
          headers: {
            'Authorization': `token ${this.githubToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            title: `ðŸš¨ Critical Build Failure Rate: ${failureRate}%`,
            body: `## Build Health Crisis Detected\n\n` +
                  `**Current Status:**\n` +
                  `- Failure Rate: ${failureRate}%\n` +
                  `- Time Period: Last 24 hours\n\n` +
                  `**Insights:**\n${insights.map(i => `- ${i.message}`).join('\\n')}\n\n` +
                  `**Immediate Actions Required:**\n` +
                  `- [ ] Investigate root cause\n` +
                  `- [ ] Apply emergency fixes\n` +
                  `- [ ] Monitor build stability\n` +
                  `- [ ] Update dependencies if needed\n\n` +
                  `*ðŸ¤– Automated by Build Health Monitor*`,
            labels: ['critical', 'build-failure', 'automated', 'high']
          })
        });
        
        console.log(`âœ… Created critical build issue for ${failureRate}% failure rate`);
      } catch (error) {
        console.error('Failed to create build issue:', error.message);
      }
    }
  }

  async run() {
    console.log('ðŸ” Starting Build Health Monitoring...');

    const builds = await this.getRecentBuilds(24);
    const analysis = this.analyzeFailurePatterns(builds);
    const insights = this.generatePredictiveInsights(analysis);

    console.log('\\nðŸ“Š Build Health Report (Last 24 Hours):');
    console.log(`- Total builds: ${builds.length}`);
    console.log(`- Failed builds: ${analysis.totalFailures}`);
    console.log(`- Failure rate: ${analysis.failureRate}%`);

    if (insights.length > 0) {
      console.log('\\nðŸ” Predictive Insights:');
      insights.forEach(insight => {
        const emoji = insight.type === 'critical' ? 'ðŸš¨' : 
                     insight.type === 'warning' ? 'âš ï¸' : 'â„¹ï¸';
        console.log(`${emoji} ${insight.message}`);
      });
    }

    // Auto-fix suggestions
    const autoFixes = [];
    
    if (analysis.failureRate > 50) {
      autoFixes.push({
        description: 'Update dependencies to resolve build issues',
        command: 'npm update && npm audit fix'
      });
    }

    if (autoFixes.length > 0) {
      console.log('\\nðŸ”§ Applying automatic fixes...');
      await this.createAutoFixPR(autoFixes);
    }

    // Create GitHub issue for critical failures
    await this.createBuildIssue(parseFloat(analysis.failureRate), insights);

    console.log('\\nâœ… Build health monitoring complete');
  }
}

// Run if called directly
if (require.main === module) {
  new BuildHealthMonitor().run().catch(console.error);
}

module.exports = BuildHealthMonitor;